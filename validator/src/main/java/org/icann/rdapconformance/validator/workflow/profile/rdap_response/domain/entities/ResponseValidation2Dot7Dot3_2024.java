package org.icann.rdapconformance.validator.workflow.profile.rdap_response.domain.entities;

import static org.icann.rdapconformance.validator.CommonUtils.DOT;
import static org.icann.rdapconformance.validator.CommonUtils.ENTITY;
import static org.icann.rdapconformance.validator.CommonUtils.SLASH;
import static org.icann.rdapconformance.validator.CommonUtils.ZERO;

import java.util.Set;
import org.icann.rdapconformance.validator.configuration.RDAPValidatorConfiguration;
import org.icann.rdapconformance.validator.workflow.profile.rdap_response.HandleValidation;
import org.icann.rdapconformance.validator.workflow.rdap.RDAPDatasetService;
import org.icann.rdapconformance.validator.workflow.rdap.RDAPQueryType;
import org.icann.rdapconformance.validator.workflow.rdap.RDAPValidatorResults;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * 9.4.4 Exclude entities with roles "reseller", "registrar", "registrant", or "technical" validation
 *
 * For registrars: Only validates entities that exist in the domain registry (thick registry).
 * This prevents validation errors for entities in thin registries where the registry
 * doesn't have entity data and registrars hold contact information.
 */
public class ResponseValidation2Dot7Dot3_2024 extends HandleValidation {

    private static final Logger logger = LoggerFactory.getLogger(ResponseValidation2Dot7Dot3_2024.class);

    // Constants for group name
    private static final String GROUP_NAME = "rdapResponseProfile_2_7_3_validation";

    // Constants for JSON field names
    private static final String FIELD_LDH_NAME = "ldhName";
    private static final String FIELD_UNICODE_NAME = "unicodeName";
    private static final String FIELD_HANDLE = "handle";

    // Constants for entity roles to exclude
    private static final String ROLE_RESELLER = "reseller";
    private static final String ROLE_REGISTRAR = "registrar";
    private static final String ROLE_REGISTRANT = "registrant";
    private static final String ROLE_TECHNICAL = "technical";

    // Constants for JSON pointer/path conversion
    private static final String JSON_POINTER_PREFIX = "#/";
    private static final String JSON_PATH_PREFIX = "$.";

    // Entity lookup service
    private final EntityRegistryLookupService entityLookupService;

    public ResponseValidation2Dot7Dot3_2024(RDAPValidatorConfiguration config, String rdapResponse, RDAPValidatorResults results,
        RDAPDatasetService datasetService, RDAPQueryType queryType) {

        // Error code: -47600 (handle format validation)
        // Note: -47601 (EPPROID validation) is generated by HandleValidation base class
        super(config, rdapResponse, results, datasetService, queryType, -47600, ENTITY);
        this.entityLookupService = new EntityRegistryLookupService(datasetService, config);
    }

    @Override
    public String getGroupName() {
        return GROUP_NAME;
    }

    @Override
    public boolean doLaunch() {
        return queryType.equals(RDAPQueryType.DOMAIN)
            && ((config.isGtldRegistry() && !config.isThin())
            || config.isGtldRegistrar());
    }

    @Override
    protected boolean doValidate() {
        Set<String> entityJsonPointers = getPointerFromJPath(buildEntityRoleExclusionQuery());

        boolean isValid = true;
        for (String jsonPointer : entityJsonPointers) {
            String handlePointer = jsonPointer + SLASH + FIELD_HANDLE;

            // For registrars: Only validate entities that exist in the domain registry
            if (config.isGtldRegistrar()) {
                String domainName = getDomainName();
                String entityHandle = getEntityHandle(handlePointer);

                if (domainName != null && entityHandle != null) {
                    // Check if entity exists in registry (thick registry check)
                    boolean entityExistsInRegistry = entityLookupService.isEntityInThickRegistry(entityHandle, domainName);

                    if (!entityExistsInRegistry) {
                        logger.debug("Skipping validation for entity {} - not found in registry for domain {}",
                                   entityHandle, domainName);
                        continue; // Skip validation for this entity
                    }

                    logger.debug("Entity {} found in registry for domain {} - proceeding with validation",
                               entityHandle, domainName);
                }
            }

            isValid &= validateHandle(handlePointer);
        }
        return isValid;
    }

    /**
     * Builds the JSONPath query to exclude entities with specific roles.
     * @return JSONPath query string for filtering entities
     */
    private String buildEntityRoleExclusionQuery() {
        return "$.entities[?(" +
               "        !(@.roles[*] =~ /" + ROLE_RESELLER + "/) &&" +
               "        !(@.roles[*] =~ /" + ROLE_REGISTRAR + "/) &&" +
               "        !(@.roles[*] =~ /" + ROLE_REGISTRANT + "/) &&" +
               "        !(@.roles[*] =~ /" + ROLE_TECHNICAL + "/)" +
               ")]";
    }

    /**
     * Extracts the domain name from the RDAP response.
     * @return Domain name (ldhName or unicodeName), or null if not found
     */
    private String getDomainName() {
        try {
            // Try ldhName first, then unicodeName as fallback
            if (jsonObject.has(FIELD_LDH_NAME)) {
                return jsonObject.getString(FIELD_LDH_NAME);
            }

            if (jsonObject.has(FIELD_UNICODE_NAME)) {
                return jsonObject.getString(FIELD_UNICODE_NAME);
            }

            return null;
        } catch (Exception e) {
            logger.debug("Error extracting domain name from response: {}", e.getMessage());
            return null;
        }
    }

    /**
     * Extracts the entity handle from the JSON response.
     * @param handlePointer JSON pointer to the handle field (e.g., "#/entities/0/handle")
     * @return Entity handle string, or null if not found
     */
    private String getEntityHandle(String handlePointer) {
        try {
            // Convert JSON pointer to JSONPath for querying
            // e.g., "#/entities/0/handle" -> "$.entities[0].handle"
            String jsonPath = convertJsonPointerToJsonPath(handlePointer);
            if (jsonPath.contains("[") && jsonPath.contains("]")) {
                // Handle array notation - already in correct format
                Object handle = jsonObject.query(jsonPath);
                if (handle != null) {
                    return handle.toString();
                }
            }
            return null;
        } catch (Exception e) {
            logger.debug("Error extracting entity handle from pointer {}: {}", handlePointer, e.getMessage());
            return null;
        }
    }

    /**
     * Converts a JSON pointer to a JSONPath expression.
     * @param jsonPointer e.g., "#/entities/0/handle"
     * @return JSONPath expression e.g., "$.entities[0].handle"
     */
    private String convertJsonPointerToJsonPath(String jsonPointer) {
        if (jsonPointer == null || !jsonPointer.startsWith(JSON_POINTER_PREFIX)) {
            return jsonPointer;
        }

        // Remove the JSON pointer prefix (#/)
        String path = jsonPointer.substring(JSON_POINTER_PREFIX.length());

        // Split by slash and rebuild with proper JSONPath syntax
        String[] segments = path.split(SLASH);
        StringBuilder jsonPath = new StringBuilder(JSON_PATH_PREFIX);

        for (int i = ZERO; i < segments.length; i++) {
            String segment = segments[i];

            // Check if this segment is a numeric array index
            if (isNumeric(segment)) {
                // Use bracket notation for array indices
                jsonPath.append("[").append(segment).append("]");
            } else {
                // Use dot notation for object properties
                if (i > ZERO) {
                    jsonPath.append(DOT);
                }
                jsonPath.append(segment);
            }
        }

        return jsonPath.toString();
    }

    /**
     * Checks if a string represents a numeric value (array index).
     * @param str the string to check
     * @return true if the string is numeric, false otherwise
     */
    private boolean isNumeric(String str) {
        if (str == null || str.isEmpty()) {
            return false;
        }
        try {
            Integer.parseInt(str);
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }
}
